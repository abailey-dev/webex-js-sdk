/*!
 * Copyright (c) 2015-2020 Cisco Systems, Inc. See LICENSE file.
 */

import {assert} from '@webex/test-helper-chai';
import LocusDeltaParser from '@webex/plugin-meetings/src/locus-info/parser';

import basicSequenceComparisons from './lib/BasicSeqCmp.json';
import sequenceComparisons from './lib/SeqCmp';


describe('locus-info/parser', () => {
  describe('Locus Sequence Comparison Algorithm', () => {
    describe('basic sequence comparisons', () => {
      Object.keys(basicSequenceComparisons.comparisons).forEach((key) => {
        const {extractComparisonState: extract} = LocusDeltaParser;
        const incomingKey = basicSequenceComparisons.comparisons[key].new;
        const currentKey = basicSequenceComparisons.comparisons[key].current;
        const {result} = basicSequenceComparisons.comparisons[key];

        const current = basicSequenceComparisons.sequences[currentKey];
        const incoming = basicSequenceComparisons.sequences[incomingKey];
        const comparison = extract(LocusDeltaParser.compareSequence(current, incoming));

        it(key, () => {
          assert.isDefined(current);
          assert.isDefined(incoming);
          assert.equal(comparison, result);
        });
      });
    });

    describe('sequence comparisons', () => {
      Object.keys(sequenceComparisons.comparisons).forEach((key) => {
        const {extractComparisonState: extract} = LocusDeltaParser;
        const incomingKey = sequenceComparisons.comparisons[key].new;
        const currentKey = sequenceComparisons.comparisons[key].current;
        const {description, result} = sequenceComparisons.comparisons[key];

        const current = sequenceComparisons.sequences[currentKey];
        const incoming = sequenceComparisons.sequences[incomingKey];
        const comparison = extract(LocusDeltaParser.compareSequence(current, incoming));

        it(`${key} - ${description}`, () => {
          assert.isDefined(current);
          assert.isDefined(incoming);
          assert.equal(comparison, result);
        });
      });
    });

    describe('delta sequence comparisons', () => {
      const {DESYNC, USE_CURRENT, USE_INCOMING} = LocusDeltaParser.loci;
      const {extractComparisonState: extract} = LocusDeltaParser;

      function translate(action) {
        switch (action) {
          case 'ACCEPT_NEW':
            return USE_INCOMING;
          case 'KEEP_CURRENT':
            return USE_CURRENT;
          case 'DESYNC':
            return DESYNC;
          default:
            throw new Error(`${action} not recognized`);
        }
      }
      Object.keys(sequenceComparisons.update_actions).forEach((key) => {
        const incomingKey = sequenceComparisons.update_actions[key].new;
        const currentKey = sequenceComparisons.update_actions[key].current;
        const baseKey = sequenceComparisons.update_actions[key].newbase;
        const {description, result} = sequenceComparisons.update_actions[key];

        const current = {
          sequence: sequenceComparisons.sequences[currentKey]
        };
        const incoming = {
          sequence: sequenceComparisons.sequences[incomingKey],
          baseSequence: sequenceComparisons.sequences[baseKey]
        };
        const comparison = LocusDeltaParser.compare(current, incoming);
        const action = extract(comparison);

        it(`${key} - ${description}`, () => {
          assert.isDefined(current.sequence);
          assert.isDefined(incoming.sequence);
          assert.equal(action, translate(result));
        });
      });
    });
  });

  describe('Queues events', () => {
    it('has the ability to queue events', () => {
      const parser = new LocusDeltaParser();
      const output = [];
      const maxEvents = 30;

      const fakeEvents = (() => {
        const burst = [];

        for (let i = 1; i <= maxEvents; i += 1) {
          burst.push(i);
        }

        return burst;
      })();

      parser.onDeltaAction = true;
      parser.processDeltaEvent = function () {
        const fakeLoci = this.queue.dequeue();

        // nothing to do, queue is empty
        if (!fakeLoci) return;

        output.push(fakeLoci);
        this.nextEvent();
      };

      const generate = new Promise((resolve) => {
        setTimeout(() => {
          for (const event of fakeEvents) {
            parser.onDeltaEvent(event);
          }
          resolve();
        }, 0);
      });

      return generate.then(() => {
        assert.equal(output.join(), fakeEvents.join());
      });
    });
  });
});
